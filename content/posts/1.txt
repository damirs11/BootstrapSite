<p>Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указатели 
обладают большими возможностями.</p>
<p>Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *. Например, определим указатель на 
объект типа int:</p>
<pre class="brush:cpp;">int *p;</pre>
<p>Пока указатель не ссылается ни на какой объект. При этом в отличие от ссылки указатель необязательно инициализировать каким-либо значением. 
Теперь присвоим указателю адрес переменной:</p>
<pre class="brush:cpp;">
int x = 10;		// определяем переменную
int *p;			// определяем указатель
p = &x;			// указатель получает адрес переменной
</pre>
<p>Для получения адреса переменной применяется операция <span class="b">&amp;</span>. Что важно, переменная x имеет тип int, и указатель, 
который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу.</p>
<p>Если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатиричное значение:</p>
<pre class="brush:cpp;">
#include &lt;iostream&gt;

int main()
{
	int x = 10;     // определяем переменную
	int *p;         // определяем указатель
	p = &x;         // указатель получает адрес переменной
	std::cout &lt;&lt; "p = " &lt;&lt; p &lt;&lt; std::endl;
	return 0;
}
</pre>
<p>Консольный вывод программы:</p>
<div class="console">
<pre class="consoletext">
p = 0x60fe98
</pre>
</div>
<p>В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0x60fe98. То есть в памяти 
компьютера есть адрес 0x60fe98, по которому располагается переменная x. Так как переменная x представляет тип <span class="b">int</span>, 
то на большинстве архитектур она будет занимать следующие 4 байта (на конкретных архитектурах размер памяти для типа int может отличаться). Таким образом, 
переменная типа int последовательно займет ячейки памяти с адресами 0x60FE98, 0x60FE99, 0x60FE9A, 0x60FE9B.</p>
<img src="pics/5.1.png" alt="Указатели в C++" />
<p>И указатель <span class="b">p</span> будет ссылаться на адрес, по которому располагается переменная x, то есть на адрес 0x60FE98.</p>
<p>Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется 
операция <span class="b">*</span> или операция разыменования, то есть та операция, которая применяется при определении указателя. Результатом этой 
операции всегда является объект, на который указывает указатель. Применим данную операцию и получим значение переменной x:</p>
<pre class="brush:cpp;">
#include &lt;iostream&gt;

int main()
{
	int x = 10;
	int *p;
	p = &x;
	std::cout &lt;&lt; "Address = " &lt;&lt; p &lt;&lt; std::endl;
	std::cout &lt;&lt; "Value = " &lt;&lt; *p &lt;&lt; std::endl;
	return 0;
}
</pre>
<p>Консольный вывод:</p>
<div class="console">
<pre class="consoletext">
Address = 0x60fe98
Value = 10
</pre>
</div>
<p>Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:</p>
<pre class="brush:cpp;">
int x = 10;
int *p  = &x;
int y = *p;
std::cout &lt;&lt; "Value = " &lt;&lt; y &lt;&lt; std::endl;	// 10
</pre>
<p>И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:</p>
<pre class="brush:c;">
int x = 10;
int *p = &x;
*p = 45;
std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; std::endl;	 // 45
</pre>
<p>Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.</p>
<p>Создадим еще несколько указателей:</p>
<pre class="brush:cpp;">
#include &lt;iostream&gt;

int main()
{
	short c = 12;
    int d = 10;
    short s = 2;
     
    short *pc = &c;          // получаем адрес переменной с типа short
    int *pd = &d;           // получаем адрес переменной d типа int
    short *ps = &s;         // получаем адрес переменной s типа short
     
    std::cout &lt;&lt; "Variable c: address=" &lt;&lt; pc &lt;&lt; "\t value=" &lt;&lt; *pc &lt;&lt; std::endl;
    std::cout &lt;&lt; "Variable d: address=" &lt;&lt; pd &lt;&lt; "\t value=" &lt;&lt; *pd &lt;&lt; std::endl;
	std::cout &lt;&lt; "Variable s: address=" &lt;&lt; ps &lt;&lt; "\t value=" &lt;&lt; *ps &lt;&lt; std::endl;
	
	return 0;
}
</pre>
<p>В моем случае я получу следующий консольный вывод:</p>
<div class="console">
<pre class="consoletext">
Variable c: address=0x60fe92	value=12
Variable d: address=0x60fe8c	value=10
Variable s: address=0x60fe8a	value=2
</pre>
</div>
<p>По адресам можно увидеть, что переменные часто расположены в памяти рядом, но не обязательно в том порядке, в котором они определены в коде программы:</p>
